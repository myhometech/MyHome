import fs from 'fs';
import path from 'path';
import puppeteer from 'puppeteer';

export interface ConversionResult {
  pdfPath: string;
  originalImagePath: string;
  success: boolean;
  error?: string;
}

export class PDFConversionService {
  /**
   * Convert a scanned document image to PDF format
   */
  async convertImageToPDF(imagePath: string, outputDir: string): Promise<ConversionResult> {
    try {
      console.log(`Converting scanned document to PDF: ${imagePath}`);
      
      if (!fs.existsSync(imagePath)) {
        throw new Error(`Image file not found: ${imagePath}`);
      }

      // Generate PDF filename
      const imageFilename = path.basename(imagePath, path.extname(imagePath));
      const pdfFilename = `${imageFilename}_document.pdf`;
      const pdfPath = path.join(outputDir, pdfFilename);

      // Create HTML template for PDF generation
      const htmlContent = this.createPDFTemplate(imagePath, imageFilename);
      
      // Generate PDF using Puppeteer
      await this.generatePDFFromHTML(htmlContent, pdfPath);

      console.log(`Successfully converted image to PDF: ${pdfPath}`);
      
      return {
        pdfPath,
        originalImagePath: imagePath,
        success: true
      };

    } catch (error: any) {
      console.error('PDF conversion failed:', error);
      return {
        pdfPath: '',
        originalImagePath: imagePath,
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Create HTML template for PDF generation
   */
  private createPDFTemplate(imagePath: string, documentName: string): string {
    const imageBase64 = this.imageToBase64(imagePath);
    const mimeType = this.getMimeType(imagePath);

    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Scanned Document - ${documentName}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: white;
        }
        
        .document-container {
            width: 100%;
            max-width: 210mm; /* A4 width */
            margin: 0 auto;
            padding: 10mm;
            background: white;
        }
        
        .document-header {
            text-align: center;
            margin-bottom: 5mm;
            font-size: 12px;
            color: #666;
        }
        
        .document-image {
            width: 100%;
            height: auto;
            max-height: 280mm; /* A4 height minus margins */
            object-fit: contain;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .document-footer {
            margin-top: 5mm;
            text-align: center;
            font-size: 10px;
            color: #999;
        }
        
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            
            .document-container {
                padding: 0;
                margin: 0;
                max-width: none;
                width: 100%;
            }
            
            .document-image {
                border: none;
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="document-container">
        <div class="document-header">
            <h3>Scanned Document</h3>
            <p>Document: ${documentName}</p>
            <p>Processed: ${new Date().toLocaleDateString()}</p>
        </div>
        
        <img src="data:${mimeType};base64,${imageBase64}" 
             alt="Scanned Document" 
             class="document-image" />
        
        <div class="document-footer">
            <p>Generated by MyHome Document Management System</p>
        </div>
    </div>
</body>
</html>`;
  }

  /**
   * Generate PDF from HTML using Puppeteer
   */
  private async generatePDFFromHTML(htmlContent: string, outputPath: string): Promise<void> {
    let browser;
    
    try {
      browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--no-first-run',
          '--no-zygote',
          '--single-process'
        ]
      });

      const page = await browser.newPage();
      
      // Set content and wait for images to load
      await page.setContent(htmlContent, {
        waitUntil: 'networkidle0'
      });

      // Generate PDF with A4 settings
      await page.pdf({
        path: outputPath,
        format: 'A4',
        margin: {
          top: '10mm',
          right: '10mm',
          bottom: '10mm',
          left: '10mm'
        },
        printBackground: true,
        preferCSSPageSize: true
      });

    } finally {
      if (browser) {
        await browser.close();
      }
    }
  }

  /**
   * Convert image file to base64
   */
  private imageToBase64(imagePath: string): string {
    try {
      const imageBuffer = fs.readFileSync(imagePath);
      return imageBuffer.toString('base64');
    } catch (error) {
      throw new Error(`Failed to read image file: ${error}`);
    }
  }

  /**
   * Get MIME type from file extension
   */
  private getMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: { [key: string]: string } = {
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.webp': 'image/webp'
    };
    return mimeTypes[ext] || 'image/jpeg';
  }

  /**
   * Check if a file is an image
   */
  isImageFile(filePath: string): boolean {
    const ext = path.extname(filePath).toLowerCase();
    return ['.jpg', '.jpeg', '.png', '.webp'].includes(ext);
  }

  /**
   * Clean up temporary files if needed
   */
  async cleanup(filePaths: string[]): Promise<void> {
    for (const filePath of filePaths) {
      try {
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log(`Cleaned up temporary file: ${filePath}`);
        }
      } catch (error) {
        console.warn(`Failed to cleanup file ${filePath}:`, error);
      }
    }
  }
}

export const pdfConversionService = new PDFConversionService();